
Subject: Deliverables: SQL Query for Actuals vs. Forecast Analysis & LLM Prompt Instructions

Hi [Boss’s Name],

I wanted to update you on the work completed for our bookings-vs-forecast analysis:

SQL Query Development:
• Built a single, self-contained query leveraging five CTEs to identify the current fiscal week, retrieve workday counts, aggregate actuals (“bookings”) and NXT-GEN forecasts, and compute pacing metrics (percent achieved and to-go).
• Ensured it rolls up the seven-level sales hierarchy and handles territories with actuals only, forecast only, or both via a full outer join.

Documentation & Explanation:
• Provided a bullet-point breakdown of each CTE’s purpose and the final join logic.
• Listed all tables and columns used, plus an English summary of the query’s end-to-end functionality.

LLM Prompt Template:
• Crafted a ready-to-use instruction block you can feed to any LLM (ChatGPT, Claude, Llama 2, etc.) to regenerate the same SQL automatically.

Please let me know if you’d like any adjustments or if I should proceed with deploying this into our reporting pipeline.

Thanks,
Saksham Kashyap
Associate, TCS C-Band
Email: saksham.kashyap@tcs.com
Phone: +91-XXXXXXXXXX







You said:
he asked me to reverse engineer the query and generate with LLM 


ChatGPT said:

Thought for 6 seconds
Subject: Reverse-Engineered SQL Query & LLM Prompt Instructions

Hi [Boss’s Name],

Per your request, I have reverse-engineered the bookings-vs-forecast SQL into a clear, step-by-step LLM prompt. You can feed this directly into any large language model (ChatGPT, Claude, Llama 2, etc.) to regenerate the exact same query:

vbnet
Copy
Edit
You are an expert SQL developer.  Write a single query that compares “bookings” (actuals) vs. “forecast” for a given user in our sales organization.  The data is grouped by the user’s position in the sales hierarchy and includes calculated pacing fields.  Follow exactly these rules:

1. Identify the current fiscal week  
   • From table PV_MBR_NRT_SUMMARY_TV, select the latest START_TV_DTM.  
   • Name this CTE latest_summary.

2. Retrieve workday counts  
   • From PV_FISCAL_DAY_TO_YEAR, filter where CALENDAR_DATE = CAST(latest_summary.max_tv_dtm AS DATE).  
   • Select WORKDAY_IN_FISCAL_WEEK_NUM AS total_days and WORKDAY_IN_FISCAL_WTD_COUNT AS day_in_num.  
   • Name this CTE fiscal_info.

3. Aggregate actual bookings  
   • From PV_MBR_NRT_SUMMARY s, joined to PV_MBR_PROCESS_DATE p on week number.  
   • Filter to s.CEC_ID = 'schuri' and the current fiscal week.  
   • Roll up the 7-level hierarchy (L0…L6_SALES_TERRITORY_DESCR) into std_parent and std based on s.LVL.  
   • Sum these metrics:  
     ACTUAL_TO_AMT, ORACLE_ACTUAL_AMT, POS_AMT, DSV_POS_AMT,  
     EIS_CM_AMT, XAAS_BKGS_AMT, CURR_DAY_ACTUAL_AMT, CURR_DAY_ACTUAL_WTD_AMT.  
   • Name this CTE bookings.

4. Aggregate the NXT-GEN forecast  
   • From PV_MBR_NXT_GEN_FCST_DETAIL f, joined to PV_MBR_PROCESS_DATE p on week number.  
   • Filter to f.CEC_ID = 'schuri', BK_FORECAST_CATEGORY_NAME = 'Product NXT', FORECAST_TYPE_CD = 'DR_PRODUCT_NXT', and the current week.  
   • Roll up hierarchy into std_parent and std as above.  
   • Sum WEEK_FCST_AMT AS current_week_forecast.  
   • Name this CTE forecast.

5. Full-outer-join & compute pacing  
   • FULL OUTER JOIN bookings b to forecast f on (std_parent, std).  
   • Use COALESCE to unify hierarchy columns.  
   • Select all actuals and forecast columns side by side.  
   • Derive two fields:  
     – current_week_percent = ROUND( b.current_day_actual_wtd * 100.0 / f.current_week_forecast, 2 )  
     – current_week_to_go   = f.current_week_forecast – b.current_day_actual_wtd  
   • CROSS JOIN fiscal_info so total_days and day_in_num are available.  
   • ORDER BY std_parent, std.

Produce the final SQL with each of the five CTEs and a single SELECT as described above.
Let me know if you’d like any refinements or additional details.
